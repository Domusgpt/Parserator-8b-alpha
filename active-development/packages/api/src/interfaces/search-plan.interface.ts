/**
 * Core interfaces for the Parserator Architect-Extractor pattern
 * Defines the structure of SearchPlans used to coordinate the two-stage parsing process
 */

/**
 * Validation types supported by the parsing engine
 */
export type ValidationTypeEnum =
  | 'string'
  | 'email'
  | 'number'
  | 'iso_date'
  | 'string_array'
  | 'boolean'
  | 'url'
  | 'phone'
  | 'json_object';

/**
 * Downstream systems the parser can optimize for
 */
export type SystemContextType =
  | 'generic'
  | 'crm'
  | 'ecommerce'
  | 'finance'
  | 'healthcare'
  | 'legal'
  | 'logistics'
  | 'marketing'
  | 'real_estate';

/**
 * Structured description of the detected downstream system context
 */
export interface ISystemContextMetrics {
  /** Raw weighted score for the top-ranked context before converting to confidence */
  rawScore: number;

  /** Raw weighted score for the second-ranked context (0 if none) */
  secondBestScore: number;

  /** Difference between the top two scores to monitor ambiguity */
  scoreDelta: number;

  /** Whether an explicit systemContextHint was provided */
  explicitHintProvided: boolean;

  /** Whether the explicit hint matched the final context selection */
  explicitHintMatchedFinalContext: boolean;

  /** Whether the top candidate received the explicit hint boost */
  topCandidateHintBoosted: boolean;

  /** Count of domainHints provided with the request */
  domainHintsProvided: number;

  /** Number of domainHints that contributed to the top candidate */
  domainHintMatches: number;

  /** Total number of distinct signals recorded for the top candidate */
  signalCount: number;

  /** Aggregate score contribution per signal source */
  sourceBreakdown: Record<'schema' | 'instructions' | 'sample' | 'hint', number>;

  /** Top-ranked candidate type before applying ambiguity/threshold guards */
  topCandidateType?: SystemContextType;

  /** Whether ambiguity handling forced a fallback */
  ambiguous: boolean;

  /** Whether scores were below the minimum confidence threshold */
  lowConfidenceFallback: boolean;
}

export interface ISystemContext {
  /** The inferred downstream system */
  type: SystemContextType;

  /** Confidence score for the chosen context (0.0 â€“ 1.0) */
  confidence: number;

  /** Signals/keywords that influenced the classification */
  signals: string[];

  /** Human-readable explanation of the context */
  summary: string;

  /** Optional ranked list of secondary context candidates */
  alternatives?: Array<{
    type: SystemContextType;
    confidence: number;
  }>;

  /** Structured metrics that describe how the selection was made */
  metrics: ISystemContextMetrics;
}

/**
 * Individual step in a SearchPlan
 * Each step represents one piece of data to extract from the input
 */
export interface ISearchStep {
  /** The key for the final JSON output (e.g., "customerName") */
  targetKey: string;
  
  /** Human-readable description of what this data represents */
  description: string;
  
  /** Direct instruction for the Extractor LLM on how to find this data */
  searchInstruction: string;
  
  /** Type validation hint for the extracted value */
  validationType: ValidationTypeEnum;
  
  /** Whether this field must be found (affects confidence scoring) */
  isRequired: boolean;
  
  /** Optional examples to help the Extractor understand the expected format */
  examples?: string[];
  
  /** Optional regex pattern for additional validation */
  pattern?: string;
  
  /** Default value to use if extraction fails and field is not required */
  defaultValue?: any;
}

/**
 * Complete SearchPlan generated by the Architect
 * Contains all steps needed to extract structured data from unstructured input
 */
export interface ISearchPlan {
  /** Array of extraction steps to execute */
  steps: ISearchStep[];
  
  /** Total number of steps (for validation) */
  totalSteps: number;
  
  /** Estimated complexity of the parsing task */
  estimatedComplexity: 'low' | 'medium' | 'high';
  
  /** Confidence score from the Architect (0.0 to 1.0) */
  architectConfidence: number;
  
  /** Estimated tokens needed for the Extractor stage */
  estimatedExtractorTokens: number;
  
  /** Any special instructions for the Extractor */
  extractorInstructions?: string;
  
  /** Metadata about the plan generation */
  metadata: {
    /** Timestamp when plan was created */
    createdAt: string;
    
    /** Version of the Architect prompt used */
    architectVersion: string;
    
    /** Sample data length used for planning */
    sampleLength: number;
    
    /** User-provided instructions that influenced the plan */
    userInstructions?: string;

    /** Optional downstream system context guidance */
    systemContext?: ISystemContext;
  };
}

/**
 * Result from the Architect stage
 * Contains the SearchPlan plus metadata about the planning process
 */
export interface IArchitectResult {
  /** The generated SearchPlan */
  searchPlan: ISearchPlan;
  
  /** Tokens consumed by the Architect */
  tokensUsed: number;
  
  /** Processing time for the Architect stage */
  processingTimeMs: number;
  
  /** Model used for the Architect */
  model: string;
  
  /** Success indicator */
  success: boolean;
  
  /** Error details if planning failed */
  error?: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
  };
}

/**
 * Result from the Extractor stage
 * Contains the parsed data plus metadata about the extraction process
 */
export interface IExtractorResult {
  /** The extracted and structured data */
  parsedData: Record<string, any>;
  
  /** Confidence scores for each extracted field */
  fieldConfidence: Record<string, number>;
  
  /** Overall confidence score for the extraction */
  overallConfidence: number;
  
  /** Tokens consumed by the Extractor */
  tokensUsed: number;
  
  /** Processing time for the Extractor stage */
  processingTimeMs: number;
  
  /** Model used for the Extractor */
  model: string;
  
  /** Success indicator */
  success: boolean;
  
  /** Fields that failed to extract (for debugging) */
  failedFields: string[];
  
  /** Error details if extraction failed */
  error?: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
  };
}

/**
 * Complete parsing result combining both stages
 * This is what gets returned to the end user
 */
export interface IParseResult {
  /** Success indicator */
  success: boolean;
  
  /** The final parsed and structured data */
  parsedData: Record<string, any>;
  
  /** Metadata about the parsing process */
  metadata: {
    /** The SearchPlan that was generated and used */
    architectPlan: ISearchPlan;

    /** Overall confidence score (0.0 to 1.0) */
    confidence: number;

    /** Detected downstream system context */
    systemContext: ISystemContext;

    /** Total tokens used across both stages */
    tokensUsed: number;
    
    /** Total processing time across both stages */
    processingTimeMs: number;
    
    /** Tokens used by the Architect */
    architectTokens: number;
    
    /** Tokens used by the Extractor */
    extractorTokens: number;
    
    /** Processing breakdown by stage */
    stageBreakdown: {
      architect: {
        timeMs: number;
        tokens: number;
        confidence: number;
      };
      extractor: {
        timeMs: number;
        tokens: number;
        confidence: number;
      };
    };
  };
  
  /** Error details if parsing failed */
  error?: {
    code: string;
    message: string;
    stage: 'architect' | 'extractor' | 'validation' | 'orchestration';
    details?: Record<string, unknown>;
  };
}

/**
 * Validation result for extracted data
 * Used to ensure the output matches expected formats
 */
export interface IValidationResult {
  /** Whether validation passed */
  isValid: boolean;
  
  /** Fields that passed validation */
  validFields: string[];
  
  /** Fields that failed validation */
  invalidFields: string[];
  
  /** Detailed validation errors by field */
  fieldErrors: Record<string, string>;
  
  /** Overall validation score (0.0 to 1.0) */
  validationScore: number;
  
  /** Suggestions for fixing validation errors */
  suggestions: string[];
}