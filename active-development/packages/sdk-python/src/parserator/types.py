"""Pydantic models for the Parserator Python SDK."""

from __future__ import annotations

from typing import Any, Callable, Dict, List, Mapping, Optional, Sequence, Union

from typing_extensions import Literal

from pydantic import BaseModel, ConfigDict, Field, ValidationError as PydanticValidationError

ValidationType = Union[
    Literal["string"],
    Literal["number"],
    Literal["boolean"],
    Literal["email"],
    Literal["phone"],
    Literal["date"],
    Literal["iso_date"],
    Literal["url"],
    Literal["string_array"],
    Literal["number_array"],
    Literal["object"],
    Literal["custom"],
]

ErrorCode = Union[
    Literal["INVALID_API_KEY"],
    Literal["INVALID_INPUT"],
    Literal["INVALID_SCHEMA"],
    Literal["RATE_LIMIT_EXCEEDED"],
    Literal["TIMEOUT"],
    Literal["NETWORK_ERROR"],
    Literal["PARSE_FAILED"],
    Literal["VALIDATION_FAILED"],
    Literal["INSUFFICIENT_CONFIDENCE"],
    Literal["QUOTA_EXCEEDED"],
    Literal["SERVICE_UNAVAILABLE"],
    Literal["INTERNAL_ERROR"],
]


class ParseOptions(BaseModel):
    """Options that influence a parse operation."""

    model_config = ConfigDict(extra="forbid", populate_by_name=True)

    timeout: Optional[int] = Field(default=None, ge=0, description="Timeout in milliseconds")
    retries: Optional[int] = Field(default=None, ge=0, description="Number of retries for this request")
    validate_output: Optional[bool] = Field(default=None, alias="validateOutput")
    include_metadata: Optional[bool] = Field(default=None, alias="includeMetadata")
    confidence_threshold: Optional[float] = Field(
        default=None, ge=0.0, le=1.0, alias="confidenceThreshold"
    )


class SearchStep(BaseModel):
    """Represents a single step in the architect search plan."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    target_key: str = Field(alias="targetKey")
    description: str
    search_instruction: str = Field(alias="searchInstruction")
    validation_type: ValidationType = Field(alias="validationType")
    is_required: bool = Field(alias="isRequired")
    confidence: Optional[float] = None
    fallback_value: Optional[Any] = Field(default=None, alias="fallbackValue")


class SearchPlan(BaseModel):
    """High level plan generated by the architect model."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    steps: List[SearchStep]
    strategy: str
    confidence_threshold: float = Field(alias="confidenceThreshold")
    metadata: Dict[str, Any]


class ParseMetadata(BaseModel):
    """Metadata describing how a parse request was executed."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    architect_plan: Optional[SearchPlan] = Field(default=None, alias="architectPlan")
    confidence: float
    tokens_used: int = Field(alias="tokensUsed")
    processing_time_ms: int = Field(alias="processingTimeMs")
    request_id: str = Field(alias="requestId")
    timestamp: str


class ParseError(BaseModel):
    """Error information returned by the Parserator API."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    code: ErrorCode
    message: str
    details: Optional[Dict[str, Any]] = None
    suggestion: Optional[str] = None


class ParseResponse(BaseModel):
    """Response payload from the Parserator parse endpoint."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    success: bool
    parsed_data: Dict[str, Any] = Field(alias="parsedData")
    metadata: ParseMetadata
    error: Optional[ParseError] = None


class ParseRequest(BaseModel):
    """Request payload accepted by the Parserator API."""

    model_config = ConfigDict(extra="forbid", populate_by_name=True)

    input_data: str = Field(alias="inputData", min_length=1)
    output_schema: Mapping[str, Any] = Field(alias="outputSchema")
    instructions: Optional[str] = None
    options: Optional[ParseOptions] = None


class BatchOptions(BaseModel):
    """Configuration for batch parsing."""

    model_config = ConfigDict(extra="forbid", populate_by_name=True)

    concurrency: Optional[int] = Field(default=None, ge=1)
    fail_fast: Optional[bool] = Field(default=None, alias="failFast")
    preserve_order: Optional[bool] = Field(default=None, alias="preserveOrder")


class BatchParseRequest(BaseModel):
    """Batch parse payload."""

    model_config = ConfigDict(extra="forbid", populate_by_name=True)

    items: Sequence[ParseRequest]
    options: Optional[BatchOptions] = None


class BatchSummary(BaseModel):
    """Summary data for a batch response."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    total: int
    successful: int
    failed: int
    total_tokens_used: int = Field(alias="totalTokensUsed")
    total_processing_time_ms: int = Field(alias="totalProcessingTimeMs")


class BatchParseResponse(BaseModel):
    """Response for batch parsing."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    results: List[Union[ParseResponse, ParseError]]
    summary: BatchSummary


class ParseratorConfig(BaseModel):
    """Configuration used to create a :class:`ParseratorClient`."""

    model_config = ConfigDict(extra="forbid", populate_by_name=True)

    api_key: str = Field(alias="apiKey", min_length=1)
    base_url: str = Field(
        default="https://app-5108296280.us-central1.run.app",
        alias="baseUrl",
    )
    timeout: int = Field(default=30000, ge=1000)
    retries: int = Field(default=3, ge=0)
    default_options: Optional[ParseOptions] = Field(default=None, alias="defaultOptions")
    debug: bool = False


class SchemaValidationError(BaseModel):
    """Individual schema validation issue."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    path: str
    message: str
    severity: str


class SchemaValidationResult(BaseModel):
    """Result of running local schema validation helpers."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    valid: bool
    errors: List[SchemaValidationError] = Field(default_factory=list)
    suggestions: List[str] = Field(default_factory=list)


class PresetExample(BaseModel):
    """Example input/output pair for a preset."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    input: str
    expected_output: Dict[str, Any] = Field(alias="expectedOutput")


class ParsePreset(BaseModel):
    """Definition of a reusable parse preset."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    name: str
    description: str
    output_schema: Mapping[str, Any] = Field(alias="outputSchema")
    instructions: str
    examples: List[PresetExample] = Field(default_factory=list)
    options: ParseOptions


class RetryConfig(BaseModel):
    """Retry settings for HTTP calls."""

    model_config = ConfigDict(extra="forbid", populate_by_name=True)

    max_retries: int = Field(alias="maxRetries", ge=0)
    base_delay: float = Field(alias="baseDelay", ge=0.0)
    max_delay: float = Field(alias="maxDelay", ge=0.0)
    backoff_factor: float = Field(alias="backoffFactor", ge=1.0)


class ParseEvent(BaseModel):
    """Event payload emitted during parsing."""

    model_config = ConfigDict(extra="allow", populate_by_name=True)

    type: str
    timestamp: str
    data: Dict[str, Any]


EventHandler = Callable[[ParseEvent], None]


def validate_config(data: Union[ParseratorConfig, Mapping[str, Any]]) -> ParseratorConfig:
    """Validate and normalise configuration dictionaries."""

    if isinstance(data, ParseratorConfig):
        return data
    return ParseratorConfig.model_validate(data)


def validate_parse_request(
    data: Union[ParseRequest, Mapping[str, Any]]
) -> ParseRequest:
    """Validate a parse request payload."""

    if isinstance(data, ParseRequest):
        return data
    return ParseRequest.model_validate(data)


def get_validation_error_message(error: PydanticValidationError) -> str:
    """Create a concise human friendly validation error message."""

    messages: List[str] = []
    for err in error.errors():
        location = ".".join(str(part) for part in err.get("loc", []))
        prefix = f"{location}: " if location else ""
        messages.append(f"{prefix}{err.get('msg', 'Invalid value')}")
    return "; ".join(messages)


__all__ = [
    "BatchOptions",
    "BatchParseRequest",
    "BatchParseResponse",
    "BatchSummary",
    "ErrorCode",
    "EventHandler",
    "ParseError",
    "ParseEvent",
    "ParseMetadata",
    "ParseOptions",
    "ParsePreset",
    "ParseRequest",
    "ParseResponse",
    "ParseratorConfig",
    "PresetExample",
    "RetryConfig",
    "SchemaValidationError",
    "SchemaValidationResult",
    "SearchPlan",
    "SearchStep",
    "ValidationType",
    "get_validation_error_message",
    "validate_config",
    "validate_parse_request",
]
